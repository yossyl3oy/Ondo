name: Release

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild even if release exists'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create-release.outputs.id || steps.get-existing-release.outputs.id }}
      version: ${{ steps.get-version.outputs.version }}
      is_rebuild: ${{ steps.check-release.outputs.exists }}
    steps:
      - uses: actions/checkout@v4

      - name: Get version from package.json
        id: get-version
        run: echo "version=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT

      - name: Check if release exists and is complete
        id: check-release
        run: |
          if gh release view "v${{ steps.get-version.outputs.version }}" > /dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            # Check if release has all expected assets (Windows .msi, macOS .dmg files)
            ASSETS=$(gh release view "v${{ steps.get-version.outputs.version }}" --json assets -q '.assets[].name' 2>/dev/null || echo "")
            if echo "$ASSETS" | grep -q "\.msi" && echo "$ASSETS" | grep -q "\.dmg"; then
              echo "complete=true" >> $GITHUB_OUTPUT
              echo "Release is complete with all assets"
            else
              echo "complete=false" >> $GITHUB_OUTPUT
              echo "Release exists but is incomplete (missing assets)"
            fi
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "complete=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get existing release ID for rebuild
        id: get-existing-release
        if: steps.check-release.outputs.exists == 'true' && (github.event.inputs.force_rebuild == 'true' || steps.check-release.outputs.complete == 'false')
        run: |
          RELEASE_ID=$(gh release view "v${{ steps.get-version.outputs.version }}" --json id -q '.id' 2>/dev/null || echo "")
          # GitHub CLI returns database ID, we need to get the release ID from API
          RELEASE_DATA=$(gh api repos/${{ github.repository }}/releases/tags/v${{ steps.get-version.outputs.version }})
          RELEASE_ID=$(echo "$RELEASE_DATA" | jq -r '.id')
          echo "id=$RELEASE_ID" >> $GITHUB_OUTPUT
          echo "Rebuilding release with ID: $RELEASE_ID"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Release
        id: create-release
        if: steps.check-release.outputs.exists == 'false'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.get-version.outputs.version }}
          release_name: Ondo v${{ steps.get-version.outputs.version }}
          body: |
            ## Ondo v${{ steps.get-version.outputs.version }}

            Hardware temperature monitoring widget with Iron Man HUD-style interface.

            ### Downloads
            - **Windows**: Download the `.msi` or `.exe` installer
            - **macOS**: Download the `.dmg` file

            ### Changes
            See commit history for details.
          draft: false
          prerelease: false

  build-tauri:
    needs: create-release
    # Build if: new release created, force rebuild requested, or release is incomplete
    if: needs.create-release.outputs.release_id != ''
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: windows-latest
            args: ''
            rust_targets: ''
          - platform: macos-latest
            args: '--target aarch64-apple-darwin'
            rust_targets: 'aarch64-apple-darwin'
          - platform: macos-latest
            args: '--target x86_64-apple-darwin'
            rust_targets: 'x86_64-apple-darwin'

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust_targets }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Setup .NET (Windows)
        if: matrix.platform == 'windows-latest'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Build LHM CLI (Windows)
        if: matrix.platform == 'windows-latest'
        shell: pwsh
        run: |
          cd src-lhm
          # Override LibreHardwareMonitorLib to only build net8.0 (avoid net472 trimming error)
          $csprojPath = "LibreHardwareMonitor/LibreHardwareMonitorLib/LibreHardwareMonitorLib.csproj"
          $content = Get-Content $csprojPath -Raw
          $content = $content -replace '<TargetFrameworks>[^<]+</TargetFrameworks>', '<TargetFramework>net8.0</TargetFramework>'
          Set-Content $csprojPath -Value $content -NoNewline
          dotnet publish OndoHardwareMonitor.csproj -c Release -r win-x64 --self-contained true -p:PublishSingleFile=true -p:PublishTrimmed=true
          Copy-Item bin/Release/net8.0/win-x64/publish/ondo-hwmon.exe ../src-tauri/

      - name: Configure resources for Windows
        if: matrix.platform == 'windows-latest'
        shell: bash
        run: |
          node -e "
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json'));
            config.bundle.resources = ['ondo-hwmon.exe'];
            fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(config, null, 2));
          "

      - name: Cache WiX Toolset (Windows)
        if: matrix.platform == 'windows-latest'
        id: cache-wix
        uses: actions/cache@v4
        with:
          path: ~/.tauri/WixTools
          key: wix-toolset-3.14.1
          restore-keys: |
            wix-toolset-

      - name: Download WiX Toolset with retry (Windows)
        if: matrix.platform == 'windows-latest' && steps.cache-wix.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          $maxRetries = 5
          $retryDelay = 30
          $wixUrl = "https://github.com/wixtoolset/wix3/releases/download/wix3141rtm/wix314-binaries.zip"
          $wixDir = "$env:USERPROFILE\.tauri\WixTools"
          $wixZip = "$env:TEMP\wix314-binaries.zip"

          New-Item -ItemType Directory -Force -Path $wixDir | Out-Null

          for ($i = 1; $i -le $maxRetries; $i++) {
            try {
              Write-Host "Attempt $i of $maxRetries to download WiX..."
              Invoke-WebRequest -Uri $wixUrl -OutFile $wixZip -UseBasicParsing
              Write-Host "Download successful!"
              Expand-Archive -Path $wixZip -DestinationPath $wixDir -Force
              Remove-Item $wixZip
              exit 0
            } catch {
              Write-Host "Download failed: $_"
              if ($i -lt $maxRetries) {
                Write-Host "Waiting $retryDelay seconds before retry..."
                Start-Sleep -Seconds $retryDelay
              }
            }
          }
          Write-Error "Failed to download WiX after $maxRetries attempts"
          exit 1

      - name: Cache NSIS (Windows)
        if: matrix.platform == 'windows-latest'
        id: cache-nsis
        uses: actions/cache@v4
        with:
          path: ~/.tauri/NSIS
          key: nsis-3.11
          restore-keys: |
            nsis-

      - name: Download NSIS with retry (Windows)
        if: matrix.platform == 'windows-latest' && steps.cache-nsis.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          $maxRetries = 5
          $retryDelay = 30
          $nsisUrl = "https://github.com/tauri-apps/binary-releases/releases/download/nsis-3.11/nsis-3.11.zip"
          $nsisDir = "$env:USERPROFILE\.tauri\NSIS"
          $nsisZip = "$env:TEMP\nsis-3.11.zip"

          New-Item -ItemType Directory -Force -Path $nsisDir | Out-Null

          for ($i = 1; $i -le $maxRetries; $i++) {
            try {
              Write-Host "Attempt $i of $maxRetries to download NSIS..."
              Invoke-WebRequest -Uri $nsisUrl -OutFile $nsisZip -UseBasicParsing
              Write-Host "Download successful!"
              Expand-Archive -Path $nsisZip -DestinationPath $nsisDir -Force
              Remove-Item $nsisZip
              exit 0
            } catch {
              Write-Host "Download failed: $_"
              if ($i -lt $maxRetries) {
                Write-Host "Waiting $retryDelay seconds before retry..."
                Start-Sleep -Seconds $retryDelay
              }
            }
          }
          Write-Error "Failed to download NSIS after $maxRetries attempts"
          exit 1

      - name: Install dependencies
        run: npm ci

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          VITE_SENTRY_DSN: ${{ secrets.VITE_SENTRY_DSN }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
        with:
          releaseId: ${{ needs.create-release.outputs.release_id }}
          args: ${{ matrix.args }}
          includeUpdaterJson: true
          updaterJsonKeepUniversal: true
